io:
  # Исходные HFET hd5, по одному файлу на fill
  # Ожидаем путь: /cephfs/brilshare/alshevel/hf_origin/hfet/25/<fill>/<fill>.hd5
  input_dir: "/cephfs/brilshare/alshevel/hf_origin/hfet/25"
  input_pattern: "{fill}/{fill}_*.hd5"

  # Выходные файлы, чтобы не трогать старую версию
  # Будет: /cephfs/brilshare/alshevel/hf_reprocessed/hfet/25_v2/<fill>/<fill>.hd5
  output_dir: "/cephfs/brilshare/alshevel/hf_reprocessed/hfet/25"
  output_pattern: "{fill}/{fill}.hd5"

  # Имя таблицы в hd5
  node: "hfetlumi"

  # Готовая маска активных BX (должна быть shape=(3564,), dtype=int)
  # Её можно один раз сделать из beam hd5
  active_mask_pattern: "/cephfs/brilshare/alshevel/hf_masks/activeBXMask_fill{fill}.npy"

  # Type1
  type1_dir: "/cephfs/brilshare/alshevel/hf_reprocessed/hfet/25_type1"

steps:
  # Полная физическая процедура:
  # 1) восстановление истинных bxraw (afterglow LSQ);
  # 2) фит Type1 остатка;
  # 3) вычитание Type1.
  restore_rates: false
  compute_type1: true
  analyze_type1: true     # <--- НОВОЕ: включить диагностический шаг
  apply_type1: false

afterglow:
  lambda_reg: 0.01
  lambda_nonactive: 0.05

  # BX, которые жёстко зачищаем (mu_true=0) – аналог BX_TO_CLEAN
  bx_to_clean: [3488, 3489, 3490, 3491, 3553, 3554, 3555, 3556, 3557]

  # В старом коде: 'input/afterglow/hfet_lsq_test.txt' — одна и та же матрица на все fill’ы
  # Здесь можно указать абсолютный путь, без {fill} — format отработает нормально.
  hfsbr_pattern: "/eos/home-a/alshevel/hfpipe/input/afterglow/hfet_lsq_test.txt"

  n_jobs: 16

  # Из твоего куска: sigvis = 3170.19
  # bx = bxraw * 11245.6 / sigvis
  sigvis: 3170.19

type1:
  # Порог по SBIL (avg или sbil): используем и для compute_type1_coeffs,
  # и для analyze_type1_step
  sbil_min: 0.1

  # Общий список offset’ов (ΔBX), как в старом коде
  offsets: [1, 2, 3, 4]

  # Флаг: рисовать PNG в analyze_type1_step или только HDF5
  make_plots: true

#fills:
  # Для теста — один конкретный fill. Потом можно заменить списком stable_fills.
#  - 10463-11230





